import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:walking_tracker_app/services/location_service.dart';
import 'package:geolocator/geolocator.dart';

/*
  Service class to generate a route for the user to walk.
  The route is generated by querying the Overpass API for footways
  around the user's current location and then using a Depth First Search
  algorithm to find the longest possible route within a certain distance.

  Now it just finds a route whose starting point is the nearest from current location
  and the length of the route try to be closeset to target length.
  In the future we want to make user's current location as the starting point of the route
 */
class RoutesService {
  static const double routeLengthInMeters = 1000;
  static const double searchRadiusInMeters = 500;

  Future<Map<String, dynamic>> generateRoute() async {
    final currentPosition = await LocationService.getCurrentPosition();
    final startLatLng = LatLng(currentPosition.latitude, currentPosition.longitude);
    final graph = await _buildGraph(startLatLng);

    if (graph.isEmpty) {
      throw Exception('No walkable ways found nearby.');
    }
    print('Graph: $graph');
    final route = _generateRouteFromGraph(graph, startLatLng);
    print('Route: $route');
    return {'graph': graph, 'route': route};
  }

  Future<Map<LatLng, List<LatLng>>> _buildGraph(LatLng startLatLng) async {
    final overpassUrl = 'https://overpass-api.de/api/interpreter';
    final query = '''
      [out:json];
      (
        way["highway"="footway"](around:$searchRadiusInMeters,${startLatLng.latitude},${startLatLng.longitude});
        node(w);
      );
      out body;
    ''';

    final response = await http.post(Uri.parse(overpassUrl), body: {'data': query});
    if (response.statusCode != 200) {
      throw Exception('Failed to load data from Overpass API');
    }

    final data = jsonDecode(response.body);
    if (data == null || data['elements'] == null) {
      throw Exception('No data found in Overpass API response');
    }

    final elements = data['elements'] as List<dynamic>;
    final nodes = <int, LatLng>{};
    final graph = <LatLng, List<LatLng>>{};

    for (final element in elements) {
      if (element['type'] == 'node') {
        final id = element['id'];
        final lat = element['lat'];
        final lon = element['lon'];
        nodes[id] = LatLng(lat, lon);
      }
    }

    for (final element in elements) {
      if (element['type'] == 'way') {
        final wayNodes = element['nodes'] as List<dynamic>;
        for (int i = 0; i < wayNodes.length - 1; i++) {
          final startNode = nodes[wayNodes[i]];
          final endNode = nodes[wayNodes[i + 1]];
          if (startNode != null && endNode != null) {
            graph.putIfAbsent(startNode, () => []).add(endNode);
            graph.putIfAbsent(endNode, () => []).add(startNode);
          }
        }
      }
    }

    return graph;
  }

  List<LatLng> _generateRouteFromGraph(Map<LatLng, List<LatLng>> graph, LatLng startLatLng) {
    final visited = <LatLng>{};
    final route = <LatLng>[];
    final bestRoute = <LatLng>[];
    double totalDistance = 0.0;
    double bestDistance = 0.0;
    // Find the nearest node from the current location
    LatLng? findNearestNode(LatLng current) {
      LatLng? nearestNode;
      double nearestDistance = double.infinity;

      for (final node in graph.keys) {
        final distance = _calculateDistance(current, node);
        if (distance < nearestDistance) {
          nearestNode = node;
          nearestDistance = distance;
        }
      }
      print('Nearest Node: $nearestNode');
      return nearestNode;
    }

    void dfs(LatLng current) {
      if (totalDistance >= routeLengthInMeters) {
        if (totalDistance > bestDistance) {
          bestDistance = totalDistance;
          bestRoute.clear();
          bestRoute.addAll(route);
        }
        return;
      }
      visited.add(current);
      route.add(current);
      print('current: $current');
      print('route: $route');

      for (final neighbor in graph[current] ?? []) {
        if (!visited.contains(neighbor)) {
          final distance = _calculateDistance(current, neighbor);
          totalDistance += distance;
          dfs(neighbor);
          totalDistance -= distance;
        }
      }

      if (totalDistance > bestDistance) {
        bestDistance = totalDistance;
        bestRoute.clear();
        bestRoute.addAll(route);
      }

      route.removeLast();
      visited.remove(current);
      print('route: $route');
    }

    // Find the nearest node from the current location
    final nearestNode = findNearestNode(startLatLng);
    if (nearestNode != null) {
      // Start DFS from the nearest node
      dfs(nearestNode);
    }
    print('Best Route: $bestRoute');
    return bestRoute;
  }

  double _calculateDistance(LatLng start, LatLng end) {
    return Geolocator.distanceBetween(start.latitude, start.longitude, end.latitude, end.longitude);
  }
}